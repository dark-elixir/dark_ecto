defmodule DarkEcto.ContextRepo do
  @moduledoc """
  Default implementations for contexts.

  ## Parameters

  - repo: An `Ecto.Repo`
  - schema: An `Ecto.Schema`
  - preloads: An *Optional* keyword list of `Ecto.Query` preloads.

  ## Preload Parameters

  - get_by_ok: An atom or atom list.  Defaults to `preloads[:get]`
  - get_by!: An atom or atom list.  Defaults to `preloads[:get]`
  - get_by: An atom or atom list.  Defaults to `preloads[:get]`
  - get_ok: An atom or atom list.  Defaults to `preloads[:get]`
  - get!: An atom or atom list.  Defaults to `preloads[:get]`
  - get: An atom or atom list.  Defaults to `preloads[:get]`
  - list_by_facet_ok: An atom or atom list.  Defaults to `preloads[:get]`
  - list_by_facet: An atom or atom list.  Defaults to `preloads[:get]`
  - list_ok: An atom or atom list.  Defaults to `preloads[:get]`
  - list: An atom or atom list.  Defaults to `preloads[:get]`


  ## Generated functions

  Given a user schema with the singular `"user"` and plural `"users"` the following will be defined:

  - `.get_user_by_ok/1`: Delegates to `DarkEcto.ContextRepo.get_by_ok/1`
  - `.get_user_by!/1`: Delegates to `.get_user_by_ok/1`
  - `.get_user_by/1`: Delegates to `.get_user_by_ok/1`
  - `.get_user_ok/1`: Delegates to ``DarkEcto.ContextRepo.get_ok/1`
  - `.get_user!/1`: Delegates to `.get_user_ok/1`
  - `.get_user/1`: Delegates to `.get_user_ok/1`
  - `.list_users_by_facet_ok/1`: Delegates to `.list_users_ok/0` and and `.facet_users/1`.
  - `.list_users_by_facet/1`: Delegates to `.list_users_ok/0` and `.facet_users/1`.
  - `.list_users_ok/0`: Delegates to `.list_users_ok/0`
  - `.list_users/0`: Delegates to `.list_users_ok/0`
  - `.facet_users/1`: Delegates to `MyApp.Ecto.FacetBuilder.apply/2`

  ## Generated functions (Deprecated)

  Some functions are generated by not prefered.

  - `.get_user_by/1`: Favor `.get_user_by_ok/1`
  - `.get_user/1`: Favor `.get_user_ok/1`

  ## Usage:

      defmodule MyApp.Accounts do
        use DarkEcto.ContextRepo,
          repo: MyApp.Repo,
          schema: MyApp.Accounts.Schemas.User,
          preloads: [
            get_by_ok: [:notes, :broker_orgs],
          ]

        # Deprecated:
        # .get_user_by/1
        # .get_user/1
      end
  """

  alias DarkEcto.Reflections.EctoSchemaFields
  alias DarkEcto.ContextRepo
  # alias MyApp.Ecto.FacetBuilder
  alias MyApp.Ecto.OKRepo

  @type primary_key() :: integer() | String.t()
  @type clauses() :: Keyword.t() | map()
  @type facet() :: Keyword.t() | map()

  defmacro __using__(opts \\ []) do
    repo = Keyword.fetch!(opts, :repo)
    schema = Keyword.fetch!(opts, :schema)
    schema = Macro.expand(schema, __ENV__)
    # *Optional* Preloads
    preloads = Context.config_preloads(opts)

    %EctoSchemaFields{
      plural: plural,
      singular: singular,
      human_plural: human_plural,
      human_singular: human_singular
    } = EctoSchemaFields.cast(schema)

    # if Application.get_env(:MyApp, :env) in [:dev, :test] and
    #      not function_exported?(schema, :__info__, 1) do
    #   raise """
    #   [DarkEcto.ContextRepo]

    #   Module does not exist: #{inspect(schema)}
    #   """
    # end

    # credo:disable-for-next-line Credo.Check.Refactor.LongQuoteBlocks
    quote location: :keep do
      import Ecto.Query, warn: false
      alias unquote(repo)
      alias unquote(schema)

      @doc """
      Facet for filtering #{unquote(human_plural)}`.

      Returns `t:Ecto.Queryable.t/0`
      """
      @spec unquote(:"facet_#{plural}")(Ecto.Queryable.t(), Context.facet()) ::
              Ecto.Queryable.t()
      def unquote(:"facet_#{plural}")(queryable, facet) when is_map(facet) or is_list(facet) do
        Context.facet(__MODULE__, unquote(repo), queryable, Context.cast_facet(facet))
      end

      defoverridable [{unquote(:"facet_#{plural}"), 2}]

      @doc """
      Query for selecting a single #{unquote(human_singular)} by `clauses`.

      Returns `{:ok, %#{unquote(schema)}{}}` or `{:error, {queryable, reason}}`.

      ## Examples

          iex> get_#{unquote(singular)}_by_ok!(clause: "value")
          {:ok, %#{unquote(schema)}{}}

          iex> get_#{unquote(singular)}_by_ok!(clause: "value")
          {:error, {%Ecto.Query{}, :not_found}}
      """
      @spec unquote(:"get_#{singular}_by_ok")(Context.clauses()) ::
              {:ok, Ecto.Schema.t()} | {:error, OKRepo.query_error()}
      def unquote(:"get_#{singular}_by_ok")(clauses) when is_list(clauses) or is_map(clauses) do
        preloads = unquote(preloads[:get_by_ok])

        Context.get_by_ok(
          __MODULE__,
          unquote(repo),
          unquote(schema),
          unquote(:"get_#{singular}_by_ok"),
          preloads,
          [clauses]
        )
      end

      defoverridable [{unquote(:"get_#{singular}_by_ok"), 1}]

      @doc """
      Query for selecting a single #{unquote(human_singular)} by `clauses`.

      Raises `Ecto.NoResultsError` if not found.

      Returns `%#{unquote(schema)}{}`

      ## Examples

          iex> get_#{unquote(singular)}_by!(123)
          %#{unquote(schema)}{}

          iex> get_#{unquote(singular)}_by!(456)
          ** (Ecto.NoResultsError)
      """
      @spec unquote(:"get_#{singular}_by!")(Context.clauses()) :: Ecto.Schema.t() | no_return()
      def unquote(:"get_#{singular}_by!")(clauses) when is_list(clauses) or is_map(clauses) do
        preloads = unquote(preloads[:get_by!])

        Context.get_by!(
          __MODULE__,
          unquote(repo),
          unquote(schema),
          unquote(:"get_#{singular}_by_ok"),
          preloads,
          [clauses]
        )
      end

      defoverridable [{unquote(:"get_#{singular}_by!"), 1}]

      @doc """
      Query for selecting a single #{unquote(human_singular)} by `clauses`.

      Returns `%#{unquote(schema)}{}` or `nil`.

      ## Examples

          iex> get_#{unquote(singular)}_by_ok(clause: "value")
          %#{unquote(schema)}{}

          iex> get_#{unquote(singular)}_by_ok(clause: "value")
          nil
      """
      @since "1.0.0"
      @deprecated "Use #{unquote(:"get_#{singular}_by_ok")}/1 instead"
      @spec unquote(:"get_#{singular}_by")(Context.clauses()) :: Ecto.Schema.t() | nil
      def unquote(:"get_#{singular}_by")(clauses) when is_list(clauses) or is_map(clauses) do
        preloads = unquote(preloads[:get_by])

        Context.get_by(
          __MODULE__,
          unquote(repo),
          unquote(schema),
          unquote(:"get_#{singular}_by_ok"),
          preloads,
          [clauses]
        )
      end

      defoverridable [{unquote(:"get_#{singular}_by"), 1}]

      @doc """
      Query for selecting a single #{unquote(human_singular)} by `id`.

      Returns `{:ok, %#{unquote(schema)}{}}` or `{:error, {queryable, reason}}`.

      ## Examples

          iex> get_#{unquote(singular)}_ok(123)
          {:ok, %#{unquote(schema)}{}}

          iex> get_#{unquote(singular)}_ok(456)
          {:error, {%Ecto.Query{}, :not_found}}
      """
      @spec unquote(:"get_#{singular}_ok")(Context.primary_key()) ::
              {:ok, Ecto.Schema.t()} | {:error, OKRepo.query_error()}
      def unquote(:"get_#{singular}_ok")(id) when is_integer(id) or is_binary(id) do
        preloads = unquote(preloads[:get_ok])

        Context.get_ok(
          __MODULE__,
          unquote(repo),
          unquote(schema),
          unquote(:"get_#{singular}_ok"),
          preloads,
          [id]
        )
      end

      defoverridable [{unquote(:"get_#{singular}_ok"), 1}]

      @doc """
      Query for selecting a single #{unquote(human_singular)} by `id`.

      Returns `%#{unquote(schema)}{}`

      Raises `Ecto.NoResultsError` if not found.

      ## Examples

          iex> get_#{unquote(singular)}!(123)
          %#{unquote(schema)}{}

          iex> get_#{unquote(singular)}!(456)
          ** (Ecto.NoResultsError)
      """
      @spec unquote(:"get_#{singular}!")(Context.primary_key()) :: Ecto.Schema.t() | no_return()
      def unquote(:"get_#{singular}!")(id) when is_integer(id) or is_binary(id) do
        preloads = unquote(preloads[:get!])

        Context.get!(
          __MODULE__,
          unquote(repo),
          unquote(schema),
          unquote(:"get_#{singular}_ok"),
          preloads,
          [id]
        )
      end

      defoverridable [{unquote(:"get_#{singular}!"), 1}]

      @doc """
      Query for selecting a single #{unquote(human_singular)} by `id`.

      Returns `%#{unquote(schema)}{}` or `nil`.

      ## Examples

          iex> get_#{unquote(singular)}(123)
          %#{unquote(schema)}{}

          iex> get_#{unquote(singular)}(456)
          nil
      """
      @since "1.0.0"
      @deprecated "Use #{unquote(:"get_#{singular}_ok")}/1 instead"
      @spec unquote(:"get_#{singular}")(Context.primary_key()) :: Ecto.Schema.t() | nil
      def unquote(:"get_#{singular}")(id) when is_integer(id) or is_binary(id) do
        preloads = unquote(preloads[:get])

        Context.get(
          __MODULE__,
          unquote(repo),
          unquote(schema),
          unquote(:"get_#{singular}_ok"),
          preloads,
          [id]
        )
      end

      defoverridable [{unquote(:"get_#{singular}"), 1}]

      @doc """
      Query for selecting multiple #{unquote(human_plural)} by `facet`.

      Returns `{:ok, [%#{unquote(schema)}{}]}`.

      ## Examples

          iex> list_#{unquote(plural)}_by_facet_ok(clause: "valid")
          {:ok, [%#{unquote(schema)}{}]}

          iex> list_#{unquote(plural)}_by_facet_ok(clause: "invalid")
          {:ok, []}
      """
      @spec unquote(:"list_#{plural}_by_facet_ok")(Context.facet()) :: {:ok, [Ecto.Schema.t()]}
      def unquote(:"list_#{plural}_by_facet_ok")(facet) when is_list(facet) or is_map(facet) do
        preloads = unquote(preloads[:list_by_facet_ok])

        Context.all_ok(
          __MODULE__,
          unquote(repo),
          unquote(:"facet_#{plural}")(unquote(schema), Context.cast_facet(facet)),
          unquote(:"list_#{plural}_ok"),
          preloads,
          []
        )
      end

      defoverridable [{unquote(:"list_#{plural}_by_facet_ok"), 1}]

      @doc """
      Query for selecting multiple #{unquote(human_plural)} by `facet`.

      Returns `[%#{unquote(schema)}{}]`.

          iex> list_#{unquote(plural)}_by_facet(clause: "valid")
          [%#{unquote(schema)}{}]

          iex> list_#{unquote(plural)}_by_facet(clause: "invalid")
          []
      """
      @spec unquote(:"list_#{plural}_by_facet")(Context.facet()) :: [Ecto.Schema.t()]
      def unquote(:"list_#{plural}_by_facet")(facet) when is_list(facet) or is_map(facet) do
        preloads = unquote(preloads[:list_by_facet])

        Context.all(
          __MODULE__,
          unquote(repo),
          unquote(:"facet_#{plural}")(unquote(schema), Context.cast_facet(facet)),
          unquote(:"list_#{plural}_ok"),
          preloads,
          []
        )
      end

      defoverridable [{unquote(:"list_#{plural}_by_facet"), 1}]

      @doc """
      Query for selecting multiple #{unquote(human_plural)}`.

      Returns `{:ok, [%#{unquote(schema)}{}]}`.

          iex> list_#{unquote(plural)}_ok()
          {:ok, [%#{unquote(schema)}{}]}

          iex> list_#{unquote(plural)}_ok()
          {:ok, []}
      """
      @spec unquote(:"list_#{plural}_ok")() :: {:ok, Ecto.Schema.t()}
      def unquote(:"list_#{plural}_ok")() do
        preloads = unquote(preloads[:list_ok])

        Context.all_ok(
          __MODULE__,
          unquote(repo),
          unquote(schema),
          unquote(:"list_#{plural}_ok"),
          preloads,
          []
        )
      end

      defoverridable [{unquote(:"list_#{plural}_ok"), 0}]

      @doc """
      Query for selecting multiple #{unquote(human_plural)}`.

      Returns `[%#{unquote(schema)}{}]`.

          iex> list_#{unquote(plural)}()
          [%#{unquote(schema)}{}]

          iex> list_#{unquote(plural)}()
          []
      """
      @spec unquote(:"list_#{plural}")() :: Ecto.Schema.t()
      def unquote(:"list_#{plural}")() do
        preloads = unquote(preloads[:list])

        Context.all(
          __MODULE__,
          unquote(repo),
          unquote(schema),
          unquote(:"list_#{plural}_ok"),
          preloads,
          []
        )
      end
    end
  end

  def config_preloads(opts) when is_list(opts) do
    preloads = Keyword.get(opts, :preloads, [])

    # Default to the `:get` or `:list` options.
    get = List.wrap(preloads[:get])
    list = List.wrap(preloads[:list])

    [
      get_by_ok: preloads[:get_by_ok] || get,
      get_by!: preloads[:get_by!] || get,
      get_by: preloads[:get_by] || get,
      get_ok: preloads[:get_ok] || get,
      get!: preloads[:get!] || get,
      get: get,
      list_by_facet_ok: preloads[:list_by_facet_ok] || list,
      list_by_facet: preloads[:list_by_facet] || list,
      list_ok: preloads[:list_ok] || list,
      list: list
    ]
  end

  defp maybe_preload(queryable, _repo, preloads) when is_list(preloads) do
    import Ecto.Query
    preload(queryable, ^preloads)
  end

  def get_by_ok(_caller, repo, queryable, _fun, preloads, [clauses]) when is_list(preloads) do
    queryable
    |> maybe_preload(repo, preloads)
    |> repo.get_by_ok(clauses)
  end

  def get_ok(_caller, repo, queryable, _fun, preloads, [id]) when is_list(preloads) do
    queryable
    |> maybe_preload(repo, preloads)
    |> repo.get_ok(id)
  end

  def all_ok(_caller, repo, queryable, _fun, preloads, []) when is_list(preloads) do
    queryable
    |> maybe_preload(repo, preloads)
    |> repo.all_ok()
  end

  def facet(_caller, _repo, queryable, facet) when is_list(facet) do
    # import MyApp.Ecto.Builders
    # # filter(queryable, facet)
    # filter_in(queryable, facet)
  end

  def get_by(caller, _repo, _queryable, fun, preloads, [clauses]) when is_list(preloads) do
    case apply(caller, fun, [clauses]) do
      # case caller.get_by_ok(clauses) do
      {:ok, result} -> result
      _ -> nil
    end
  end

  def get_by!(caller, _repo, _queryable, fun, preloads, [clauses]) when is_list(preloads) do
    case apply(caller, fun, [clauses]) do
      # case caller.get_by_ok(clauses) do
      {:ok, result} ->
        result

      {:error, {queryable, reason}} ->
        raise Ecto.NoResultsError, queryable: queryable, message: "#{inspect(reason)}"
    end
  end

  def get(caller, _repo, _queryable, fun, preloads, [id]) when is_list(preloads) do
    case apply(caller, fun, [id]) do
      # case caller.get_ok(id) do
      {:ok, result} -> result
      _ -> nil
    end
  end

  def get!(caller, _repo, _queryable, fun, preloads, [id]) when is_list(preloads) do
    case apply(caller, fun, [id]) do
      # case caller.get_ok(id) do
      {:ok, result} ->
        result

      {:error, {queryable, reason}} ->
        raise Ecto.NoResultsError, queryable: queryable, message: "#{inspect(reason)}"
    end
  end

  def all(caller, repo, queryable, fun, preloads, []) do
    {:ok, results} = all_ok(caller, repo, queryable, fun, preloads, [])
    results
  end

  def cast_facet(facet) when is_map(facet) do
    Enum.into(facet, [])
  end

  def cast_facet(facet) when is_list(facet) do
    facet
  end
end
